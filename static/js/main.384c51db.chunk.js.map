{"version":3,"sources":["stars.jpg","index.js"],"names":["module","exports","Square","props","className","onClick","value","Board","state","squares","Array","fill","xTurn","isTorus","extraBoard","changeSize","bind","opponentMove","i","this","squareClick","key","slice","calculateWinner","setState","event","target","squaresLength","length","sideLength","Math","sqrt","lines","getLines","defenseLines","possibleLines","lineCoords","lineVals","map","coord","some","val","push","worstLine","maxX","defenseLine","numX","j","bestLine","maxO","possibleLine","numO","prevProps","prevState","winner","status","numCells","cellNumList","renderSquareMatrix","row","rowItems","col","squareNum","renderSquare","drawBoard","rowNumber","drawHelperBoard","numCellsOptions","id","style","float","newGame","class","htmlFor","name","defaultValue","onChange","React","Component","diagonal","counterDiagonal","verticalLine","horizontalLine","torusDiagonal","torusCounterDiagonal","every","pairs","a","b","pair","ReactDOM","render","document","getElementById"],"mappings":"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","file":"static/js/main.384c51db.chunk.js","sourcesContent":["module.exports = __webpack_public_path__ + \"static/media/stars.aab1fd75.jpg\";","import React from 'react';\r\nimport ReactDOM from 'react-dom';\r\nimport './index.css';\r\nimport stars from './stars.jpg';\r\n\r\n// base square for the game\r\n// the onClick is inherited from the Board class\r\nfunction Square(props) {\r\n  return (\r\n    <button\r\n      className=\"square\"\r\n      onClick={props.onClick}\r\n    >\r\n      {/*store null, 'X', or 'O'*/}\r\n      {props.value}\r\n    </button>\r\n  );\r\n}\r\n\r\n// the board and control buttons\r\n\r\nclass Board extends React.Component {\r\n  constructor(props) {\r\n    super(props);\r\n    this.state = {\r\n      squares: Array(9).fill(null),\r\n      xTurn: true,\r\n      isTorus: false,\r\n      extraBoard: false,\r\n    };\r\n\r\n    this.changeSize = this.changeSize.bind(this);\r\n    this.opponentMove = this.opponentMove.bind(this);\r\n  }\r\n\r\n  // draw a square with value squares[i]\r\n  renderSquare(i) {\r\n    return (\r\n      <Square\r\n        value={this.state.squares[i]}\r\n        onClick={() => this.squareClick(i)}\r\n        key={i}\r\n      />\r\n    );\r\n  }\r\n\r\n  // if a square has not been filled already,\r\n  // and no-one has won, fill in the square with\r\n  // either 'X' or 'O', depending on whose turn it is\r\n  squareClick(i) {\r\n    const squares = this.state.squares.slice();\r\n    if (calculateWinner(squares, this.state.isTorus) || squares[i]){\r\n      return;\r\n    }\r\n    squares[i] = this.state.xTurn ? 'X' : 'O';\r\n    this.setState({\r\n      squares: squares,\r\n      xTurn: !this.state.xTurn,\r\n    });\r\n  }\r\n\r\n  // change size of the board using a select menu\r\n  // gives the board a new blank array of the desired size\r\n  changeSize(event) {\r\n    this.setState({\r\n      squares: Array(event.target.value ** 2).fill(null),\r\n      xTurn: true,\r\n    })\r\n  }\r\n\r\n  // make a new game by re-setting squares to be an empty array\r\n  newGame() {\r\n    const squaresLength = this.state.squares.length\r\n    this.setState({\r\n      squares:Array(squaresLength).fill(null),\r\n      xTurn: true,\r\n    });\r\n  }\r\n\r\n  opponentMove() {\r\n    const squares = this.state.squares.slice();\r\n    const sideLength = Math.sqrt(squares.length);\r\n    const lines = getLines(this.state.squares, this.state.isTorus);\r\n\r\n    const defenseLines = [];\r\n    const possibleLines = [];\r\n    for (let i = 0; i < lines.length; i++){\r\n      const lineCoords = lines[i];\r\n      const lineVals = lineCoords.map(coord => squares[coord]);\r\n      // if there is no X in a line, it could be used for offense\r\n      if ( !lineVals.some( (val) => val === 'X')){\r\n        possibleLines.push(lineCoords);\r\n      }\r\n      // if there is an X in a line but no O, it could be used for defense\r\n      else if ( !lineVals.some( (val) => val === 'O')){\r\n        defenseLines.push(lineCoords);\r\n      }\r\n    }\r\n\r\n    let worstLine = defenseLines[0];\r\n    let maxX = 0;\r\n    for (let i = 0; i < defenseLines.length; i++){\r\n      let defenseLine = defenseLines[i];\r\n\r\n      let numX = 0;\r\n      for (let j = 0; j < defenseLine.length; j++){\r\n        if( squares[defenseLine[j]] === 'X'){\r\n          numX += 1;\r\n        }\r\n      }\r\n      if (numX > maxX){\r\n        maxX = numX;\r\n        worstLine = defenseLine;\r\n      }\r\n    }\r\n\r\n    let bestLine = possibleLines[0];\r\n    let maxO = 0;\r\n    for (let i = 0; i < possibleLines.length; i++){\r\n      let possibleLine = possibleLines[i];\r\n\r\n      let numO = 0;\r\n      for (let j = 0; j < possibleLine.length; j++){\r\n        if ( squares[possibleLine[j]] === 'O'){\r\n          numO += 1;\r\n        }\r\n      }\r\n      if ( numO > maxO){\r\n        maxO = numO;\r\n        bestLine = possibleLine;\r\n      }\r\n    }\r\n\r\n    if (maxX === sideLength - 1 || possibleLines.length === 0){\r\n      bestLine = worstLine;\r\n    }\r\n\r\n    for (let i = 0; i < sideLength; i++){\r\n      if (squares[bestLine[i]] == null){\r\n        this.squareClick(bestLine[i]);\r\n        return;\r\n      }\r\n    }\r\n  }\r\n\r\n  componentDidUpdate(prevProps, prevState) {\r\n    let winner = calculateWinner(this.state.squares, this.state.isTorus);\r\n    if (this.state.xTurn !== prevState.xTurn){\r\n      if (!this.state.xTurn && !winner) {\r\n        this.opponentMove();\r\n      }\r\n    }\r\n  }\r\n\r\n  render() {\r\n    // display who is the next player\r\n    let status ='Next player: ' + (this.state.xTurn ? 'X' : 'O');\r\n\r\n    // copy of squares\r\n    const squares = this.state.squares.slice();\r\n    // number of cells along one side of the square\r\n    const numCells = Math.sqrt(squares.length);\r\n\r\n    // see if there is a winner yet\r\n    // if so, change the status to display the winner\r\n    var winner = calculateWinner(squares, this.state.isTorus);\r\n    if (winner) {\r\n      status = \"Winner: \" + winner;\r\n    }\r\n\r\n    // make a list [0,1,2,3, ... ]\r\n    // to label the squares with\r\n    const cellNumList = [];\r\n    for (let i = 0; i < Math.sqrt(this.state.squares.length); i++){\r\n      cellNumList.push(i);\r\n    }\r\n\r\n    // matrix with rows like [this.renderSquare(0), this.rendersquare(1), ...]\r\n    // this will be used to make the square board\r\n    const renderSquareMatrix = [];\r\n    for (let row = 0; row < Math.sqrt(this.state.squares.length); row++){\r\n      let rowItems = [];\r\n      for (let col = 0; col < Math.sqrt(this.state.squares.length); col++){\r\n        // each new row increments by the side-length of the square\r\n        let squareNum = col + row * Math.sqrt(this.state.squares.length);\r\n        rowItems.push(this.renderSquare(squareNum));\r\n      }\r\n      renderSquareMatrix.push(rowItems);\r\n    }\r\n\r\n    // draw the board\r\n    const drawBoard = (\r\n      cellNumList.map((rowNumber) =>\r\n        <div className=\"board-row\" key={rowNumber}>\r\n          {renderSquareMatrix[rowNumber]}\r\n        </div>\r\n      )\r\n    );\r\n\r\n    // draw the helper board with \"board-row-greyed\" class\r\n    const drawHelperBoard = (\r\n      cellNumList.map((rowNumber) =>\r\n        <div className=\"board-row board-row-greyed\" key={rowNumber}>\r\n          {renderSquareMatrix[rowNumber]}\r\n        </div>\r\n      )\r\n    );\r\n\r\n    // give 10 options for cell numbers\r\n    const numCellsOptions = [];\r\n    for (let i = 0; i < 10; i++){\r\n      numCellsOptions.push(<option value={i} key={i}>{i}x{i}</option>);\r\n    }\r\n\r\n    return (\r\n      <div id=\"page\">\r\n      {/*<img id=\"stars\" src={stars} alt=\"Stars Background\"/>*/}\r\n      <div id=\"fullBoard\">\r\n        <div id=\"mainBoard\" style={{float: \"left\"}}>\r\n        {/*display the current status of the game */}\r\n        <div className=\"status\">{status}</div>\r\n        {/*display the board squares*/}\r\n        {drawBoard}\r\n        {/*draw the helper board if desired*/}\r\n        {this.state.extraBoard ? drawHelperBoard : \"\"}\r\n      <br/>\r\n      {/*Show \"playing on a torus\" if true*/}\r\n      {this.state.isTorus ? \"Playing on a torus\" : \"\"}\r\n        </div>\r\n\r\n       <br/>\r\n\r\n       <div id=\"boardControls\">\r\n        <button onClick={() => this.newGame()}>New Game</button>\r\n        <br/>\r\n        <label class=\"controlDesc\" htmlFor=\"numCells\">Choose the board size:</label>\r\n        <br/>\r\n        <select\r\n          name=\"numCells\"\r\n          id=\"numCells\"\r\n          defaultValue={numCells}\r\n          onChange={this.changeSize}\r\n        >\r\n          {numCellsOptions}\r\n        </select>\r\n        <br/>\r\n        <span class=\"controlDesc\">Change the type of board:</span>\r\n        <br/>\r\n        {/*choose torus board or normal board*/}\r\n        <button onClick={\r\n          () => this.state.isTorus ?\r\n            this.setState({isTorus: false, extraBoard: false})\r\n            : this.setState({isTorus: true})\r\n          }\r\n          id=\"torusBoardButton\"\r\n        >\r\n          {this.state.isTorus ? \"Normal Board\" : \"Torus Board\"}\r\n        </button>\r\n\r\n        <br/>\r\n        <br/>\r\n        {/*if the board is a torus board, you can choose to show the extra board\r\n          or not*/}\r\n        {this.state.isTorus ?\r\n          <button onClick={\r\n            () => this.state.extraBoard ?\r\n              this.setState({extraBoard: false})\r\n              : this.setState({extraBoard: true})\r\n          } id=\"helperBoardButton\">\r\n          Show helper board\r\n        </button>\r\n        : \"\"\r\n        }\r\n      </div>\r\n    </div>\r\n    </div>\r\n    );\r\n  }\r\n}\r\n\r\n// find all lines in the game as an array\r\nfunction getLines(squares, isTorus) {\r\n  const sideLength = Math.sqrt(squares.length);\r\n  const lines = [];\r\n\r\n  // arrays to store diagonal and counter diagonal lines\r\n  const diagonal = [];\r\n  const counterDiagonal = [];\r\n\r\n  // put all lines in the list lines\r\n  for (let i = 0; i < sideLength; i++){\r\n    // get vertical and horizontal lines\r\n    let verticalLine = [];\r\n    let horizontalLine = [];\r\n    for (let j = 0; j < sideLength; j++){\r\n      verticalLine.push(i + j * sideLength);\r\n      horizontalLine.push(i * sideLength + j);\r\n    }\r\n    lines.push(verticalLine);\r\n    lines.push(horizontalLine);\r\n\r\n    // get diagonal lines\r\n    diagonal.push(i * (sideLength + 1));\r\n    counterDiagonal.push( (1+i) * (sideLength - 1));\r\n  }\r\n  lines.push(diagonal);\r\n  lines.push(counterDiagonal);\r\n\r\n  // if the game is played on a torus\r\n  // and the game is at least 3x3 (otherwise no change)\r\n  // add some lines to the set\r\n  // i.e. for a 3x3, add 057, 138, 156, 237\r\n  // 0 1 2\r\n  // 3 4 5\r\n  // 6 7 8\r\n  if (isTorus && squares.length > 4){\r\n    // keep track of diagonals by where they start in the top column j\r\n    for (let j = 1; j < sideLength; j++){\r\n      let torusDiagonal = [];\r\n      let torusCounterDiagonal = [];\r\n\r\n      // the first sideLength - j entries follow the same pattern\r\n      // as the normal diagonal and counterDiagonals, except\r\n      // shifted up or down by j\r\n      for (let i = 0; i < sideLength - j; i++){\r\n        torusDiagonal.push( i * (sideLength + 1) + j );\r\n        torusCounterDiagonal.push( (1 + i) * (sideLength - 1) - j );\r\n      }\r\n\r\n      // the last j entries follow the same pattern as the first\r\n      // sideLength - j entries, except shifted up or down by sideLength\r\n      for (let i = sideLength - j; i < sideLength; i++){\r\n        torusDiagonal.push( i * (sideLength + 1) + j - sideLength );\r\n        torusCounterDiagonal.push( (1 + i) * (sideLength - 1) - j + sideLength );\r\n      }\r\n\r\n      //alert(\"diagonal \" + j + \" : \" + torusDiagonal);\r\n      //alert(\"counterDiagonal \" + j + \" : \" + torusCounterDiagonal);\r\n\r\n      // add the new torus lines to the list of lines\r\n      lines.push(torusDiagonal);\r\n      lines.push(torusCounterDiagonal);\r\n    }\r\n  }\r\n  return lines;\r\n}\r\n\r\n\r\nfunction calculateWinner(squares, isTorus) {\r\n  const sideLength = Math.sqrt(squares.length);\r\n  const lines = getLines(squares, isTorus);\r\n\r\n  // on a 0x0 board, the first player automatically wins\r\n  // TODO: make this take into account which player goes first\r\n  // (i.e. read from xTurn)\r\n  if (sideLength === 0){\r\n    return 'X';\r\n  }\r\n\r\n  // determine if there is a winner\r\n  for (let i = 0; i < lines.length; i++) {\r\n    const lineCoords = lines[i];\r\n    // list of values at the line coordinate positions\r\n    const lineVals = lineCoords.map(coord => squares[coord]);\r\n\r\n    // if the entry on the end is non-null and all other entries are\r\n    // equal to it, someone has won\r\n    if (lineVals[0] && lineVals.every( (val) => val === lineVals[0])){\r\n      return lineVals[0];\r\n    }\r\n  }\r\n\r\n  // check if there is a tie\r\n  // (this could be made more strict, i.e. if it is X's turn\r\n  // and the only open line has an O in it, the program will wait until\r\n  // X makes a move to declare a tie)\r\n\r\n  // if the board is 2x2 or smaller, there is no way to have a tie\r\n  if (squares.length < 9){\r\n    return null;\r\n  }\r\n\r\n  for (let i = 0; i < lines.length; i++) {\r\n    const lineCoords = lines[i];\r\n    const lineVals = lineCoords.map(coord => squares[coord]);\r\n\r\n    let pairs = [];\r\n    for (let a = 0; a < lines.length - 1; a++){\r\n      for (let b = a + 1; b < lines.length; b++){\r\n        pairs.push([lineVals[a], lineVals[b]]);\r\n      }\r\n    }\r\n    // if there is a pair of non-null squares with non-equal values,\r\n    // then this line (line i) cannot be won. Skip to the next line\r\n    if (pairs.some(\r\n      (pair) => pair[0] && pair[1] && pair[0] !== pair[1]\r\n    )) {\r\n      continue;\r\n    }\r\n    // if the line is not bad, someone could still win the game\r\n    return null;\r\n  }\r\n  // if all lines are bad, it is a tie\r\n  return 'Tie';\r\n}\r\n\r\n// ========================================\r\n\r\nReactDOM.render(\r\n  <Board/>,\r\n  document.getElementById('root')\r\n);\r\n"],"sourceRoot":""}